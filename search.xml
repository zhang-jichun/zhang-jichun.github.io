<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>lintcode-13-字符串查找-哈希法</title>
    <url>/2022/02/08/lintcode-13-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BE-%E5%93%88%E5%B8%8C%E6%B3%95/</url>
    <content><![CDATA[<p><a href="https://lc.jiuzhang.com/problem/13/">https://lc.jiuzhang.com/problem/13/</a></p>
<h1 id="哈希法"><a href="#哈希法" class="headerlink" title="哈希法"></a>哈希法</h1><ol>
<li>特殊情况判断</li>
<li>哈希函数构造：31为自订值，BASE为模值，取asc值</li>
<li>continue用法</li>
<li>利用前值哈希计算后值哈希的方法<span id="more"></span>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @param source: </span></span><br><span class="line"><span class="string">    @param target: </span></span><br><span class="line"><span class="string">    @return: return the index</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span>(<span class="params">self, source, target</span>):</span></span><br><span class="line">        <span class="comment"># Write your code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> target:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(source) &lt; <span class="built_in">len</span>(target):</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        BASE = <span class="number">10086</span></span><br><span class="line">        targetCode = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> target:</span><br><span class="line">            targetCode = (targetCode * <span class="number">31</span> + <span class="built_in">ord</span>(ch)) % BASE</span><br><span class="line"></span><br><span class="line">        power = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(target)):</span><br><span class="line">            power = (power * <span class="number">31</span>) % BASE</span><br><span class="line"></span><br><span class="line">        hashCode = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(source)):</span><br><span class="line">            hashCode = (hashCode * <span class="number">31</span> + <span class="built_in">ord</span>(source[i])) % BASE</span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(target) - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> i &gt;= <span class="built_in">len</span>(target):</span><br><span class="line">                hashCode = (hashCode - <span class="built_in">ord</span>(source[i - <span class="built_in">len</span>(target)]) * power) % BASE</span><br><span class="line">                <span class="keyword">if</span> hashCode &lt; <span class="number">0</span> :</span><br><span class="line">                    hashCode = hashCode + BASE          </span><br><span class="line">            <span class="keyword">if</span> hashCode == targetCode:</span><br><span class="line">                <span class="keyword">if</span> target == source[i - <span class="built_in">len</span>(target) + <span class="number">1</span> : i + <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">return</span> i - <span class="built_in">len</span>(target) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>lintcode</category>
      </categories>
  </entry>
  <entry>
    <title>lintcode-14-二分查找-找下标最小的结果</title>
    <url>/2022/02/14/lintcode-14-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-%E6%89%BE%E4%B8%8B%E6%A0%87%E6%9C%80%E5%B0%8F%E7%9A%84%E7%BB%93%E6%9E%9C/</url>
    <content><![CDATA[<p><a href="https://www.lintcode.com/problem/14/">https://www.lintcode.com/problem/14/</a></p>
<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><ul>
<li>递推法</li>
<li>left + 1 &lt; right<span id="more"></span>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @param nums: The integer array.</span></span><br><span class="line"><span class="string">    @param target: Target to find.</span></span><br><span class="line"><span class="string">    @return: The first position of target. Position starts from 0.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">binarySearch</span>(<span class="params">self, nums, target</span>):</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">return</span> self.helper(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums), target)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, nums, left, right, target</span>):</span></span><br><span class="line">        <span class="keyword">while</span> left + <span class="number">1</span> &lt; right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">if</span> mid == <span class="number">0</span> <span class="keyword">or</span> nums[mid] != nums[mid - <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">return</span> mid</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> nums[left] == target:</span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        <span class="keyword">elif</span> nums[right] == target:</span><br><span class="line">            <span class="keyword">return</span> right</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>lintcode</category>
      </categories>
  </entry>
  <entry>
    <title>lintcode-200-最长回文子串-中心扩散法</title>
    <url>/2022/01/29/lintcode-200-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2-%E4%B8%AD%E5%BF%83%E6%89%A9%E6%95%A3%E6%B3%95/</url>
    <content><![CDATA[<p><a href="https://www.lintcode.com/problem/200/description">https://www.lintcode.com/problem/200/description</a></p>
<h1 id="中心扩散法"><a href="#中心扩散法" class="headerlink" title="中心扩散法"></a>中心扩散法</h1><ol>
<li>分两次遍历中心点，奇数点，偶数点。</li>
<li>找到单次遍历的最长回文串。</li>
<li>res保留最长的。<span id="more"></span>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @param s: input string</span></span><br><span class="line"><span class="string">    @return: a string as the longest palindromic substring</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        res = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(s), <span class="number">1</span>):</span><br><span class="line">            temp = self.findLongest(s, i, i)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(temp) &gt; <span class="built_in">len</span>(res):</span><br><span class="line">                res = temp</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(s)-<span class="number">1</span>, <span class="number">1</span>):</span><br><span class="line">            temp = self.findLongest(s, i, i+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(temp) &gt; <span class="built_in">len</span>(res):</span><br><span class="line">                res = temp</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLongest</span>(<span class="params">self, temp, left, right</span>):</span></span><br><span class="line">        res = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">while</span>(temp[left] == temp[right]):</span><br><span class="line">            res = temp[left : right + <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> left - <span class="number">1</span> &gt;=<span class="number">0</span> <span class="keyword">and</span> right + <span class="number">1</span> &lt; <span class="built_in">len</span>(temp):</span><br><span class="line">                left -= <span class="number">1</span></span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span>   </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>lintcode</category>
      </categories>
      <tags>
        <tag>lintcode</tag>
      </tags>
  </entry>
  <entry>
    <title>lintcode-200-最长回文子串-动态规划</title>
    <url>/2022/01/29/lintcode-200-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<p><a href="https://www.lintcode.com/problem/200/description">https://www.lintcode.com/problem/200/description</a></p>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><ol>
<li>创建表格。</li>
<li>初始化两条对角线。</li>
<li>遍历表格的每一列，行标代表起始坐标，列标代表终止坐标。</li>
<li>创建表格的工程中res记录最大者。<span id="more"></span>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @param s: input string</span></span><br><span class="line"><span class="string">    @return: a string as the longest palindromic substring</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        res = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        isPalindrome = [[<span class="literal">False</span>] * <span class="built_in">len</span>(s) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s))]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            isPalindrome[i][i] = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(res) &lt; <span class="number">1</span>:</span><br><span class="line">                res = s[i : i + <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s) - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> s[i] == s[i + <span class="number">1</span>]:</span><br><span class="line">                isPalindrome[i][i + <span class="number">1</span>] = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(res) &lt; <span class="number">2</span>:</span><br><span class="line">                    res = s[i: i+<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">len</span>(s), <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> left <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, right - <span class="number">1</span>, <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> isPalindrome[left + <span class="number">1</span>][right - <span class="number">1</span>] == <span class="literal">True</span> <span class="keyword">and</span> s[left] == s[right]:</span><br><span class="line">                    isPalindrome[left][right] = <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">len</span>(res) &lt; right - left + <span class="number">1</span>:</span><br><span class="line">                        res = s[left : right + <span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>lintcode</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>lintcode-200-最长回文子串-暴力解</title>
    <url>/2022/01/28/lintcode-200-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2-%E6%9A%B4%E5%8A%9B%E8%A7%A3/</url>
    <content><![CDATA[<p><a href="https://www.lintcode.com/problem/200/description">https://www.lintcode.com/problem/200/description</a></p>
<h1 id="三层循环暴力解法"><a href="#三层循环暴力解法" class="headerlink" title="三层循环暴力解法"></a>三层循环暴力解法</h1><ol>
<li>start,end两层循环取出待检查字符串</li>
<li>isPalindrome判断字符串是否为回文串</li>
<li>判断temp与res长短，留存最长temp<span id="more"></span>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @param s: input string</span></span><br><span class="line"><span class="string">    @return: a string as the longest palindromic substring</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        res = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> start <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(s), <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(start, <span class="built_in">len</span>(s), <span class="number">1</span>):</span><br><span class="line">                temp = s[start : end + <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> self.isPalindrome(temp) <span class="keyword">is</span> <span class="literal">True</span> <span class="keyword">and</span> <span class="built_in">len</span>(temp) &gt; <span class="built_in">len</span>(res):</span><br><span class="line">                    res = temp </span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, temp</span>):</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(temp) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right <span class="keyword">and</span> temp[left] == temp[right]):</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> left &gt; right:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>lintcode</category>
      </categories>
  </entry>
  <entry>
    <title>lintcode-366-斐波那契数列</title>
    <url>/2022/02/14/lintcode-366-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<p><a href="https://www.lintcode.com/problem/366/description">https://www.lintcode.com/problem/366/description</a></p>
<h1 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h1><ul>
<li>递归法会StackOverflow</li>
<li>采用递推法<span id="more"></span>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @param n: an integer</span></span><br><span class="line"><span class="string">    @return: an ineger f(n)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        temp = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> temp[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">elif</span> n == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> temp[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, n, <span class="number">1</span>):</span><br><span class="line">                temp[<span class="number">0</span>] = temp[<span class="number">1</span>]</span><br><span class="line">                temp[<span class="number">1</span>] = temp[<span class="number">2</span>]</span><br><span class="line">                temp[<span class="number">2</span>] = temp[<span class="number">0</span>] + temp[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">return</span> temp[<span class="number">2</span>]</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>lintcode</category>
      </categories>
  </entry>
  <entry>
    <title>lintcode-415-有效回文串-向相双指针</title>
    <url>/2022/02/09/lintcode-415-%E6%9C%89%E6%95%88%E5%9B%9E%E6%96%87%E4%B8%B2-%E5%90%91%E7%9B%B8%E5%8F%8C%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<p><a href="https://www.lintcode.com/problem/415/">https://www.lintcode.com/problem/415/</a></p>
<h1 id="有效回文串"><a href="#有效回文串" class="headerlink" title="有效回文串"></a>有效回文串</h1><ul>
<li>向相双指针</li>
<li>.lower() .upper()</li>
<li>.isdigit() .isalpha()<span id="more"></span>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @param s: A string</span></span><br><span class="line"><span class="string">    @return: Whether the string is a valid palindrome</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> (s[left].isdigit() <span class="keyword">or</span> s[left].isalpha()):</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> (s[right].isdigit() <span class="keyword">or</span> s[right].isalpha()):</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> s[left].lower() == s[right].lower():</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>lintcode</category>
      </categories>
  </entry>
  <entry>
    <title>lintcode-463-整数排序-归并</title>
    <url>/2022/02/11/lintcode-463-%E6%95%B4%E6%95%B0%E6%8E%92%E5%BA%8F-%E5%BD%92%E5%B9%B6/</url>
    <content><![CDATA[<p><a href="https://www.lintcode.com/problem/463/">https://www.lintcode.com/problem/463/</a></p>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><ul>
<li>先把数组一切二，两边递归调用归并排序</li>
<li>两边归并后，将两数组合并</li>
<li>合并数组中需要开辟额外空间，开辟空间也要时间，整体没有快排快速。<span id="more"></span>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @param A: an integer array</span></span><br><span class="line"><span class="string">    @return: nothing</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortIntegers</span>(<span class="params">self, A</span>):</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        self.mergeSort(A, <span class="number">0</span>, <span class="built_in">len</span>(A) - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span>(<span class="params">self, A, start, end</span>):</span></span><br><span class="line">        <span class="keyword">if</span> start &gt;= end:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.mergeSort(A, start, (start + end) // <span class="number">2</span>)</span><br><span class="line">        self.mergeSort(A, (start + end)//<span class="number">2</span> + <span class="number">1</span>, end)</span><br><span class="line">        self.merge(A, start, (start + end) // <span class="number">2</span>, end)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self, A, start, mid, end</span>):</span></span><br><span class="line">        temp1 = A[start : mid + <span class="number">1</span>]</span><br><span class="line">        temp2 = A[mid + <span class="number">1</span> : end + <span class="number">1</span>]</span><br><span class="line">        ind1 = <span class="number">0</span></span><br><span class="line">        ind2 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, end + <span class="number">1</span>, <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> ind1 &lt; <span class="built_in">len</span>(temp1) <span class="keyword">and</span> ind2 &lt; <span class="built_in">len</span>(temp2):</span><br><span class="line">                <span class="keyword">if</span> temp1[ind1] &lt;= temp2[ind2]:</span><br><span class="line">                    A[i] = temp1[ind1]</span><br><span class="line">                    ind1 += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    A[i] = temp2[ind2]</span><br><span class="line">                    ind2 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> ind1 &gt;= <span class="built_in">len</span>(temp1):</span><br><span class="line">                A[i] = temp2[ind2]</span><br><span class="line">                ind2 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> ind2 &gt;= <span class="built_in">len</span>(temp2):</span><br><span class="line">                A[i] = temp1[ind1]</span><br><span class="line">                ind1 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>lintcode</category>
      </categories>
  </entry>
  <entry>
    <title>lintcode-457-二分查找</title>
    <url>/2022/02/14/lintcode-457-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<p><a href="https://www.lintcode.com/problem/457/">https://www.lintcode.com/problem/457/</a></p>
<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><ul>
<li>注意binarySearch函数的参数构成，方便递归</li>
<li>函数参数加self,调用函数加self<span id="more"></span>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @param nums: An integer array sorted in ascending order</span></span><br><span class="line"><span class="string">    @param target: An integer</span></span><br><span class="line"><span class="string">    @return: An integer</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findPosition</span>(<span class="params">self, nums, target</span>):</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">return</span> self.binarySearch(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span>, target)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">binarySearch</span>(<span class="params">self, nums, start, end, target</span>):</span></span><br><span class="line">        <span class="keyword">if</span> start &gt; end:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        mid = (start + end) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">            <span class="keyword">return</span> self.binarySearch(nums, start, mid - <span class="number">1</span>, target)</span><br><span class="line">        <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">            <span class="keyword">return</span> self.binarySearch(nums, mid + <span class="number">1</span>, end, target)</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>lintcode</category>
      </categories>
  </entry>
  <entry>
    <title>lintcode-457-二分查找-找下标最大的结果</title>
    <url>/2022/02/14/lintcode-457-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-%E6%89%BE%E4%B8%8B%E6%A0%87%E6%9C%80%E5%A4%A7%E7%9A%84%E7%BB%93%E6%9E%9C/</url>
    <content><![CDATA[<p><a href="https://www.lintcode.com/problem/458/">https://www.lintcode.com/problem/458/</a></p>
<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><ul>
<li>left + 1 &lt; right</li>
<li>异常检测 if not nums:</li>
<li>没有查到要返回-1<span id="more"></span>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @param nums: An integer array sorted in ascending order</span></span><br><span class="line"><span class="string">    @param target: An integer</span></span><br><span class="line"><span class="string">    @return: An integer</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lastPosition</span>(<span class="params">self, nums, target</span>):</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.helper(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span>, target)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, nums, left, right, target</span>):</span></span><br><span class="line">        <span class="keyword">while</span> left + <span class="number">1</span> &lt; right:</span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                left = mid</span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> nums[right] == target:</span><br><span class="line">            <span class="keyword">return</span> right</span><br><span class="line">        <span class="keyword">elif</span> nums[left] == target:</span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>lintcode</category>
      </categories>
  </entry>
  <entry>
    <title>lintcode-463-整数排序-快排</title>
    <url>/2022/02/10/lintcode-463-%E6%95%B4%E6%95%B0%E6%8E%92%E5%BA%8F-%E5%BF%AB%E6%8E%92/</url>
    <content><![CDATA[<h1 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h1><ul>
<li>left &lt;= right 保证最后left right不会重叠</li>
<li>A[left] &lt; pivot 而不是 A[left] &lt;= pivot 保证不会因为pivot恰巧是最小值而导致指针越界，A[left] &lt; pivot 保证了指针在pivot处一定会停下来做交换，否则right会一直-1到值为-1越界而left无变化。参考[3,2,1,4,5]</li>
<li>左右指针停下来后交换值，然后要left+1 right-1<span id="more"></span>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @param A: an integer array</span></span><br><span class="line"><span class="string">    @return: nothing</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortIntegers</span>(<span class="params">self, A</span>):</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> A:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        </span><br><span class="line">        self.quickSort(A, <span class="number">0</span>, <span class="built_in">len</span>(A) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quickSort</span>(<span class="params">self, A, start, end</span>):</span></span><br><span class="line">        left = start</span><br><span class="line">        right = end</span><br><span class="line">        <span class="keyword">if</span> left &gt;= right:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        pivot = A[(left + right) // <span class="number">2</span>]</span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            <span class="keyword">while</span> left &lt;= right <span class="keyword">and</span> A[left] &lt; pivot:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt;= right <span class="keyword">and</span> A[right] &gt; pivot:</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> left &lt;= right:</span><br><span class="line">                temp = A[left]</span><br><span class="line">                A[left] = A[right]</span><br><span class="line">                A[right] = temp</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">        self.quickSort(A, start, right)</span><br><span class="line">        self.quickSort(A, left, end)</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>整数排序</category>
      </categories>
  </entry>
  <entry>
    <title>lintcode-5-第K大元素-快排法</title>
    <url>/2022/02/11/lintcode-5-%E7%AC%ACK%E5%A4%A7%E5%85%83%E7%B4%A0-%E5%BF%AB%E6%8E%92%E6%B3%95/</url>
    <content><![CDATA[<p><a href="https://www.lintcode.com/problem/5/">https://www.lintcode.com/problem/5/</a></p>
<h1 id="第K大元素"><a href="#第K大元素" class="headerlink" title="第K大元素"></a>第K大元素</h1><ul>
<li>应用快排的基本原理</li>
<li>注意从大到小排列</li>
<li>最后比较K与left,right的大小关系而划分区间</li>
<li>注意left,right中间有可能会隔一个元素，元素位置要与K比较<span id="more"></span>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @param k: An integer</span></span><br><span class="line"><span class="string">    @param nums: An array</span></span><br><span class="line"><span class="string">    @return: the Kth largest element</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthLargestElement</span>(<span class="params">self, k, nums</span>):</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.quickSelect(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span>, k)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quickSelect</span>(<span class="params">self, nums, start, end, k</span>):</span></span><br><span class="line">        <span class="keyword">if</span> start == end <span class="keyword">and</span> start == k - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[start]</span><br><span class="line"></span><br><span class="line">        left = start</span><br><span class="line">        right = end</span><br><span class="line">        pivot = nums[(start + end) // <span class="number">2</span>]</span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            <span class="keyword">while</span> left &lt;= right <span class="keyword">and</span> nums[left] &gt; pivot:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt;= right <span class="keyword">and</span> nums[right] &lt; pivot:</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> left &lt;= right:</span><br><span class="line">                temp = nums[left]</span><br><span class="line">                nums[left] = nums[right]</span><br><span class="line">                nums[right] = temp</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> k - <span class="number">1</span> &lt;= right:</span><br><span class="line">            <span class="keyword">return</span> self.quickSelect(nums, start, right, k)</span><br><span class="line">        <span class="keyword">elif</span> k - <span class="number">1</span> &gt;= left:</span><br><span class="line">            <span class="keyword">return</span> self.quickSelect(nums, left, end, k)</span><br><span class="line">        <span class="keyword">elif</span> left - right == <span class="number">2</span> <span class="keyword">and</span> k - <span class="number">1</span> == left - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[left - <span class="number">1</span>]</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>lintcode</category>
      </categories>
  </entry>
  <entry>
    <title>lintcode-56-两数之和-哈希表</title>
    <url>/2022/02/09/lintcode-56-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    <content><![CDATA[<p><a href="https://www.lintcode.com/problem/56/description">https://www.lintcode.com/problem/56/description</a></p>
<ul>
<li>python的哈希表就是字典</li>
<li>enumerate(numbers)<span id="more"></span>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @param numbers: An array of Integer</span></span><br><span class="line"><span class="string">    @param target: target = numbers[index1] + numbers[index2]</span></span><br><span class="line"><span class="string">    @return: [index1, index2] (index1 &lt; index2)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, numbers, target</span>):</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        hashset = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> ind, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(numbers):</span><br><span class="line">            <span class="keyword">if</span> target - num <span class="keyword">in</span> hashset:</span><br><span class="line">                <span class="keyword">return</span> [hashset[target - num], ind]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hashset[num] = ind</span><br><span class="line">        <span class="keyword">return</span> [-<span class="number">1</span>, -<span class="number">1</span>]</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>lintcode</category>
      </categories>
  </entry>
  <entry>
    <title>lintcode-891-有效回文2-双指针</title>
    <url>/2022/02/09/lintcode-891-%E6%9C%89%E6%95%88%E5%9B%9E%E6%96%872-%E5%8F%8C%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<p><a href="https://www.lintcode.com/problem/891/solution">https://www.lintcode.com/problem/891/solution</a></p>
<h1 id="有效回文2"><a href="#有效回文2" class="headerlink" title="有效回文2"></a>有效回文2</h1><ul>
<li>向相双指针</li>
<li>依靠isPalindrome()判断简单回文</li>
<li>调用同类函数加self.<span id="more"></span>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @param s: a string</span></span><br><span class="line"><span class="string">    @return: whether you can make s a palindrome by deleting at most one character</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="keyword">if</span> s[left] == s[right]:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validPalindrome</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="comment"># Write your code here</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="keyword">if</span> s[left] == s[right]:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> self.isPalindrome(s[left : right]) <span class="keyword">or</span> self.isPalindrome(s[left + <span class="number">1</span> : right + <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>lintcode</category>
      </categories>
  </entry>
  <entry>
    <title>lintcode-56-两数之和-排序双指针</title>
    <url>/2022/02/09/lintcode-56-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-%E6%8E%92%E5%BA%8F%E5%8F%8C%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<p><a href="https://www.lintcode.com/problem/56/description">https://www.lintcode.com/problem/56/description</a></p>
<ul>
<li>列表生成式</li>
<li>enumerate用法</li>
<li>.sort() sorted()用法</li>
<li>return最后也要排序<span id="more"></span>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @param numbers: An array of Integer</span></span><br><span class="line"><span class="string">    @param target: target = numbers[index1] + numbers[index2]</span></span><br><span class="line"><span class="string">    @return: [index1, index2] (index1 &lt; index2)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, numbers, target</span>):</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> numbers:</span><br><span class="line">            <span class="keyword">return</span> [-<span class="number">1</span>, -<span class="number">1</span>]</span><br><span class="line">        nums = [(num, ind) <span class="keyword">for</span> ind, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(numbers)]</span><br><span class="line">        nums.sort()</span><br><span class="line"></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="keyword">if</span> nums[left][<span class="number">0</span>] + nums[right][<span class="number">0</span>] &lt; target:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[left][<span class="number">0</span>] + nums[right][<span class="number">0</span>] &gt; target:</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">sorted</span>([nums[left][<span class="number">1</span>],nums[right][<span class="number">1</span>]])</span><br><span class="line">        <span class="keyword">return</span> [-<span class="number">1</span>, -<span class="number">1</span>]</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>lintcode</category>
      </categories>
  </entry>
  <entry>
    <title>九章算法-02-真实案例-最长回文子串</title>
    <url>/2022/01/27/%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95-02-%E7%9C%9F%E5%AE%9E%E6%A1%88%E4%BE%8B-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="2-1-最长回文子串"><a href="#2-1-最长回文子串" class="headerlink" title="2.1 最长回文子串"></a>2.1 最长回文子串</h1><p>lintcode200<br><a href="https://www.lintcode.com/problem/200/description">https://www.lintcode.com/problem/200/description</a><br>abcd 子串 ab,bc… 子序列 ac,bd…</p>
<ol>
<li>暴力解法-相向型双指针-时间复杂度on3-不合格</li>
<li>马拉车算法on,并不是面试官需要的算法，面试并不考记忆。<span id="more"></span>
<h1 id="2-2-on3代码实现差异"><a href="#2-2-on3代码实现差异" class="headerlink" title="2.2 on3代码实现差异"></a>2.2 on3代码实现差异</h1></li>
<li>注意写题目要异常检测。</li>
<li>不要用单个字母变量。</li>
<li>加空格。逻辑块用空行分开。</li>
<li>缩进不要超过3层。</li>
</ol>
<h1 id="2-3-基于中心线枚举的算法"><a href="#2-3-基于中心线枚举的算法" class="headerlink" title="2.3 基于中心线枚举的算法"></a>2.3 基于中心线枚举的算法</h1><ol>
<li>on2时间复杂度。n个奇数长度中心点，n-1个偶数长度中心点。双指针L向左走R向右走。</li>
<li>避免重复代码，避免全局变量，避免递归。</li>
<li>python作为面试语言可以缩短时间。</li>
</ol>
<h1 id="2-4-动态规划法"><a href="#2-4-动态规划法" class="headerlink" title="2.4 动态规划法"></a>2.4 动态规划法</h1><h1 id="2-5-面试评价标准"><a href="#2-5-面试评价标准" class="headerlink" title="2.5 面试评价标准"></a>2.5 面试评价标准</h1><ol>
<li>不一定非要最优解，要贴近面试。</li>
<li>BugFree</li>
<li>CodingStyle</li>
<li>逻辑易懂</li>
<li>没有冗余代码</li>
<li>边界检测与异常处理</li>
<li>九章solution可查看答案</li>
<li>noHire weakHire Hire strongHire</li>
</ol>
<h1 id="2-6-十二招快速提高"><a href="#2-6-十二招快速提高" class="headerlink" title="2.6 十二招快速提高"></a>2.6 十二招快速提高</h1><ol>
<li>codingQuality助力bugFree</li>
<li>二元运算符两边加空格，单元运算符不加空格</li>
<li>各种扩号和for，if之间加空格</li>
<li>逗号分号后面加空格</li>
<li>空行分割不同逻辑块</li>
<li>变量名用1-2单词</li>
<li>确保一个函数内部不超过3层缩进</li>
<li>包装子函数减少缩进</li>
<li>多用continue少用if，少用else<br> ```<br> for…<pre><code> if...   
     做一些处理
     做一些处理
</code></pre>
 for…<pre><code> if not ...
     continue
 做一些处理
 做一些处理
</code></pre>
 ```hes</li>
<li>对入口参数进行异常检测</li>
<li>确保下标不越界，确保对象不是空</li>
<li>不用全局变量</li>
</ol>
]]></content>
      <categories>
        <category>九章算法</category>
      </categories>
  </entry>
  <entry>
    <title>九章算法-01-高效刷题</title>
    <url>/2022/01/25/%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95-01-%E9%AB%98%E6%95%88%E5%88%B7%E9%A2%98/</url>
    <content><![CDATA[<ul>
<li>有的题不要刷，有的题目可以多刷。</li>
<li>缩进与循环尽量不要超过三层，若多层可以采用子函数，代码缩进越多bug越多。<span id="more"></span></li>
<li>进步最快的是代码被更高级的员工code review。</li>
<li>magicNumber(定义wall=1,water=2)</li>
<li>缺乏项目经验：耦合度高，重复代码，全局变量。</li>
<li>解耦合：整体逻辑用子函数表达，子函数实现具体步骤。</li>
<li>好的代码不需要注释。更清晰的变量名，更易懂的逻辑。</li>
<li>子函数化，避免全局变量可以降低bug.</li>
<li>逻辑思维能力，代码质量，代码风格，异常检测。</li>
<li>面试是一个试用的过程，不是考试的过程。</li>
<li>不要闷头写，先沟通清除再写，写完了再解释。</li>
<li>不会刻意要提示，但先自己努力一下。</li>
<li>会就会，不会就是不会，坦诚很重要。</li>
<li>一个Django项目课，可以咨询。</li>
<li>面试语言首推python,其次java,不要用C++。</li>
<li>lintcode 算法能力，bugFree能力，题量。</li>
<li>lintcodeCat帮助评估算法能力。</li>
<li>判断算法考不考，带名字的算法都不考。</li>
<li>参考考察表v4.1</li>
<li>熟悉每一种常用的数据结构。</li>
<li>互联网公司考systemDesign多，软件公司考OOD</li>
<li>OOD有5章节10课时的课程。</li>
<li>BehaviorQuestion也要有准备，主要准备与面试公司的联系。</li>
</ul>
]]></content>
      <categories>
        <category>九章算法</category>
      </categories>
  </entry>
  <entry>
    <title>九章算法-04-复杂度与双指针</title>
    <url>/2022/02/09/%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95-04-%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E5%8F%8C%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h1 id="算法的四个复杂度"><a href="#算法的四个复杂度" class="headerlink" title="算法的四个复杂度"></a>算法的四个复杂度</h1><ul>
<li>时间复杂度-注重</li>
<li>空间复杂度</li>
<li>编程复杂度-能看得懂</li>
<li>思维复杂度-能想得出<span id="more"></span>
<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1></li>
<li>On On2 On3 O(m+n) O(1) O(logn) O(nlogn) O(2n) O(nn) O(n!)</li>
<li>快排最坏是On2，平均复杂度是Onlogn</li>
</ul>
<h1 id="双指针的分类"><a href="#双指针的分类" class="headerlink" title="双指针的分类"></a>双指针的分类</h1><ul>
<li>O(n+m)&gt;Omax(n,m)&gt;O((m+n)/2)导出O(m+n)=O(max(m,n))</li>
<li>On常用算法双指针、打擂台、单调栈、单调队列</li>
<li>相向双指针-判断回文<ul>
<li>reverse 翻转字符串 判断回文</li>
<li>two sum 两数和 三数和</li>
<li>partition 快排 颜色排序</li>
</ul>
</li>
<li>背向双指针-最长回文</li>
<li>同向双指针</li>
</ul>
<h1 id="有效回文串-validPalindrome-1-amp-2"><a href="#有效回文串-validPalindrome-1-amp-2" class="headerlink" title="有效回文串 validPalindrome 1&amp;2"></a>有效回文串 validPalindrome 1&amp;2</h1><ul>
<li>常用函数<ul>
<li>isdigit()</li>
<li>isalpha()</li>
<li>lower()</li>
<li>upper()</li>
</ul>
</li>
</ul>
<h1 id="twoSum"><a href="#twoSum" class="headerlink" title="twoSum"></a>twoSum</h1><ul>
<li>哈希表 时间On 空间On</li>
<li>排序+双指针 时间Onlogn 空间O1<ul>
<li>如果数据已排序，则双指针算法更好，因为不需要额外空间</li>
<li>如果需要返回下标，则双指针算法不如哈希表，双指针算法需要与下标共同排序</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>九章算法</category>
      </categories>
  </entry>
  <entry>
    <title>九章算法-03-真实案例-字符串查找</title>
    <url>/2022/01/31/%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95-03-%E7%9C%9F%E5%AE%9E%E6%A1%88%E4%BE%8B-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h1 id="implement-strStr"><a href="#implement-strStr" class="headerlink" title="implement strStr()"></a>implement strStr()</h1><p>查询字符串中的子串<br>KMP算法-三个人名的缩写<br>首先暴力方法实现</p>
<span id="more"></span>
<p>java不可以用substring,python不可以用切片<br>保证不越界<br>+1 -1 的问题代入一个特殊值验证<br>rabin-karp算法利用hashcode<br>hash(abcd) = [a<em>31(3) + b</em>31(2) + c<em>31(1) + d</em>31(0)]%10(6)<br>31叫做matchNumber可以随意设置，31为经验值</p>
]]></content>
      <categories>
        <category>九章算法</category>
      </categories>
  </entry>
  <entry>
    <title>九章算法-05-两个排序算法</title>
    <url>/2022/02/10/%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95-05-%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><ul>
<li>先整体有序，后局部有序partition</li>
<li>等于标记点的情况要尽可能均分，就需要&gt;= &lt;=<span id="more"></span>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1></li>
<li>先局部有序，后整体有序，分治</li>
<li>实际快排更快一点，因为归并需要开辟额外空间，这部分也需要花费时间</li>
</ul>
<h1 id="两种排序比较"><a href="#两种排序比较" class="headerlink" title="两种排序比较"></a>两种排序比较</h1><ul>
<li>快排平均时间复杂度nlogn，最坏时间复杂度On2。空间复杂度O1，不稳定排序。先整体有序，后微观有序。</li>
<li>归并排序时间复杂度就是nlogn。空间复杂度On，稳定排序。先局部有序，后整体有序。</li>
</ul>
<h1 id="快速选择算法"><a href="#快速选择算法" class="headerlink" title="快速选择算法"></a>快速选择算法</h1><ul>
<li>Kth Largest Element</li>
<li>应用快排基本原理</li>
<li>按照K所在的区间进行剪枝操作</li>
</ul>
]]></content>
      <categories>
        <category>九章算法</category>
      </categories>
  </entry>
  <entry>
    <title>九章算法-06-二分法</title>
    <url>/2022/02/14/%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95-06-%E4%BA%8C%E5%88%86%E6%B3%95/</url>
    <content><![CDATA[<h1 id="斐波那契数列写递归"><a href="#斐波那契数列写递归" class="headerlink" title="斐波那契数列写递归"></a>斐波那契数列写递归</h1><ul>
<li>recursion recursive</li>
<li>类似数学归纳法<span id="more"></span></li>
<li>耗费栈空间 stackOverflow 耗费空间：参数 返回值 局部变量</li>
<li>递归三要素<ul>
<li>递归定义 参数 </li>
<li>递归拆解 n变为n-1 或n-2</li>
<li>递归终止条件</li>
</ul>
</li>
</ul>
<h1 id="用递归来写二分法"><a href="#用递归来写二分法" class="headerlink" title="用递归来写二分法"></a>用递归来写二分法</h1>]]></content>
      <categories>
        <category>九章算法</category>
      </categories>
  </entry>
  <entry>
    <title>九章算法-07-二分法模板</title>
    <url>/2022/02/14/%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95-07-%E4%BA%8C%E5%88%86%E6%B3%95%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h1 id="二分法原理"><a href="#二分法原理" class="headerlink" title="二分法原理"></a>二分法原理</h1><ul>
<li>基于有序数组</li>
<li>确定start,end,mid<span id="more"></span>
<h1 id="二分法模板"><a href="#二分法模板" class="headerlink" title="二分法模板"></a>二分法模板</h1></li>
<li>目标的最后一个索引</li>
<li>两道题firstPositionOfTarget LastPositionOfTarget</li>
<li>start + 1 &lt; end 避免死循环</li>
<li>单独判断start 与 end</li>
</ul>
]]></content>
      <categories>
        <category>九章算法</category>
      </categories>
  </entry>
  <entry>
    <title>基于github与hexo博客创建全流程</title>
    <url>/2022/01/25/%E5%9F%BA%E4%BA%8Egithub%E4%B8%8Ehexo%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA%E5%85%A8%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="创建github帐号并安装hexo"><a href="#创建github帐号并安装hexo" class="headerlink" title="创建github帐号并安装hexo"></a>创建github帐号并安装hexo</h1><p><a href="https://zhuanlan.zhihu.com/p/26625249">https://zhuanlan.zhihu.com/p/26625249</a></p>
<span id="more"></span>
<h1 id="无法部署的问题"><a href="#无法部署的问题" class="headerlink" title="无法部署的问题"></a>无法部署的问题</h1><p>spawn failed 解决方法是修改配置文件<br><a href="https://blog.zhheo.com/p/128998ac.html">https://blog.zhheo.com/p/128998ac.html</a></p>
<h1 id="最新版next下载"><a href="#最新版next下载" class="headerlink" title="最新版next下载"></a>最新版next下载</h1><p>原文的next主题连接已不再更新<br><a href="https://github.com/theme-next/hexo-theme-next">https://github.com/theme-next/hexo-theme-next</a></p>
<h1 id="Next主题配置"><a href="#Next主题配置" class="headerlink" title="Next主题配置"></a>Next主题配置</h1><p><a href="https://www.jianshu.com/p/3a05351a37dc">https://www.jianshu.com/p/3a05351a37dc</a></p>
<h1 id="分类与标签无法显示的问题"><a href="#分类与标签无法显示的问题" class="headerlink" title="分类与标签无法显示的问题"></a>分类与标签无法显示的问题</h1><p><a href="https://www.jianshu.com/p/f138032e7539">https://www.jianshu.com/p/f138032e7539</a></p>
<h1 id="markdown学习"><a href="#markdown学习" class="headerlink" title="markdown学习"></a>markdown学习</h1><p><a href="https://www.runoob.com/markdown/md-tutorial.html">https://www.runoob.com/markdown/md-tutorial.html</a><br><a href="https://www.appinn.com/markdown/">https://www.appinn.com/markdown/</a></p>
]]></content>
      <categories>
        <category>博客创建</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>九章算法-09-二分法的四重境界</title>
    <url>/2022/02/15/%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95-09-%E4%BA%8C%E5%88%86%E6%B3%95%E7%9A%84%E5%9B%9B%E9%87%8D%E5%A2%83%E7%95%8C/</url>
    <content><![CDATA[<h1 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h1><ul>
<li>折半查找，时间Ologn,空间O1</li>
<li>有序数组查找，减治思想，不属于分治</li>
<li>Ologn贴近于O1 Onlogn贴近于On<span id="more"></span>
<h1 id="第一境界"><a href="#第一境界" class="headerlink" title="第一境界"></a>第一境界</h1></li>
<li>不会死循环的二分法，start + 1 &lt; end</li>
<li>start + (end - start)/2</li>
<li>A[start] A[end] 判断</li>
</ul>
<h1 id="第二境界"><a href="#第二境界" class="headerlink" title="第二境界"></a>第二境界</h1><ul>
<li>排序数组中找到第一个或者最后一个满足条件的位置</li>
<li>447题（与14题重复）</li>
<li>460题，在排序数组中找最接近的K个数，先插入target,再左右找最近的K个数字。eg：找&lt;=3的最右数字，二分法找到分界线，后使用背向双指针，类似归并排序</li>
<li>585题，找到山脉序列中的最大值</li>
<li>159题，旋转排序数组中的最小值</li>
<li>二分法敏感词：排序数组，有序数组</li>
</ul>
<h1 id="第三境界"><a href="#第三境界" class="headerlink" title="第三境界"></a>第三境界</h1><ul>
<li>在未排序的数据集上进行二分</li>
<li>75题，寻找峰值，任意一个峰值都可以</li>
<li>面试时候可以画画图</li>
</ul>
<h1 id="第四境界"><a href="#第四境界" class="headerlink" title="第四境界"></a>第四境界</h1><ul>
<li>在答案集上进行二分</li>
<li>确定答案范围</li>
<li>验证答案大小</li>
<li>183题，木材加工</li>
</ul>
]]></content>
      <categories>
        <category>九章算法</category>
      </categories>
  </entry>
  <entry>
    <title>markdown格式测试</title>
    <url>/2022/01/25/%E6%A0%BC%E5%BC%8F%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><p>文字大小</p>
<h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><p>文字大小</p>
<h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><p>文字大小</p>
<span id="more"></span>
<h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><p>文字大小</p>
<h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><p>文字大小</p>
<h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><p>文字大小</p>
<h1 id="段落格式"><a href="#段落格式" class="headerlink" title="段落格式"></a>段落格式</h1><p>换行的话要在第一段的末尾加两个以上空格加回车<br>换行的话要在第一段的末尾加两个以上空格加回车<br>换行的话要在第一段的末尾加两个以上空格加回车  </p>
<p>换段的话两段之间加个空白段</p>
<h1 id="文体"><a href="#文体" class="headerlink" title="文体"></a>文体</h1><p><em>斜体文本</em><br><em>斜体文本</em></p>
<p><strong>粗体文本</strong><br><strong>粗体文本</strong></p>
<p><em><strong>粗斜体文本</strong></em><br>_<strong>粗斜体文本</strong></p>
<h1 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h1><hr>
<hr>
<hr>
<hr>
<hr>
<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
<ol>
<li><p>第一项</p>
</li>
<li><p>第二项</p>
</li>
<li><p>第三项</p>
</li>
<li><p>第一项：</p>
<ul>
<li>第一项嵌套的第一个元素</li>
<li>第一项嵌套的第二个元素</li>
</ul>
</li>
<li><p>第二项：</p>
<ul>
<li>第二项嵌套的第一个元素</li>
<li>第二项嵌套的第二个元素</li>
</ul>
</li>
</ol>
<h1 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h1><blockquote>
<p>最外层</p>
<blockquote>
<p>第一层嵌套</p>
<blockquote>
<p>第二层嵌套</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<p>区块中使用列表</p>
<ol>
<li>第一项</li>
<li>第二项</li>
</ol>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
</blockquote>
<ul>
<li>第一项<blockquote>
<p>菜鸟教程<br>学的不仅是技术更是梦想</p>
</blockquote>
</li>
<li>第二项</li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&#x27;RUNOOB&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>段落内嵌函数 <code>printf()</code> 函数</p>
<pre><code>printf（123）
</code></pre>
<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><p>这是一个链接 <a href="https://www.runoob.com/">菜鸟教程</a><br>直接使用链接 <a href="https://www.runoob.com/">https://www.runoob.com</a></p>
<h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><p><img src="/images/liuguanzhang.jpg" alt="头像"></p>
<h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><table>
<thead>
<tr>
<th align="left">左对齐</th>
<th align="right">右对齐</th>
<th align="center">居中对齐</th>
</tr>
</thead>
<tbody><tr>
<td align="left">单元格</td>
<td align="right">单元格</td>
<td align="center">单元格</td>
</tr>
<tr>
<td align="left">单元格</td>
<td align="right">单元格</td>
<td align="center">单元格</td>
</tr>
</tbody></table>
<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="横向流程图"><a href="#横向流程图" class="headerlink" title="横向流程图"></a>横向流程图</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[方形] --&gt;B(圆角)</span><br><span class="line">    B --&gt; C&#123;条件a&#125;</span><br><span class="line">    C --&gt;|a=1| D[结果1]</span><br><span class="line">    C --&gt;|a=2| E[结果2]</span><br><span class="line">    F[横向流程图]</span><br></pre></td></tr></table></figure>





















]]></content>
      <categories>
        <category>博客创建</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>格式</tag>
      </tags>
  </entry>
  <entry>
    <title>lintcode-460-在排序数组中找最接近的K个数-二分法</title>
    <url>/2022/02/16/lintcode-460-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%89%BE%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84K%E4%B8%AA%E6%95%B0-%E4%BA%8C%E5%88%86%E6%B3%95/</url>
    <content><![CDATA[<h1 id="在排序数组中找最接近的K个数"><a href="#在排序数组中找最接近的K个数" class="headerlink" title="在排序数组中找最接近的K个数"></a>在排序数组中找最接近的K个数</h1><ul>
<li>首先用二分法找到小于等于target中的最大数下标</li>
<li>而后采用背向双指针从该下标开始找最接近的K个数<span id="more"></span>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @param A: an integer array</span></span><br><span class="line"><span class="string">    @param target: An integer</span></span><br><span class="line"><span class="string">    @param k: An integer</span></span><br><span class="line"><span class="string">    @return: an integer array</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kClosestNumbers</span>(<span class="params">self, A, target, k</span>):</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> A:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        flag = self.findFlag(A, target, k)</span><br><span class="line">        <span class="keyword">return</span> self.getRes(A, target, k, flag)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findFlag</span>(<span class="params">self, A, target, k</span>):</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(A) - <span class="number">1</span></span><br><span class="line">        flag = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left + <span class="number">1</span> &lt; right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> A[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> A[mid] &lt; target:</span><br><span class="line">                left = mid</span><br><span class="line">            <span class="keyword">elif</span> A[mid] &gt; target:</span><br><span class="line">                right = mid</span><br><span class="line">        <span class="keyword">if</span> A[left] == target:</span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        <span class="keyword">elif</span> A[right] == target:</span><br><span class="line">            <span class="keyword">return</span> right</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> left <span class="comment">#小于等于target的最大值为定位点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRes</span>(<span class="params">self, A, target, k, flag</span>):</span></span><br><span class="line">        res = []</span><br><span class="line">        left = flag</span><br><span class="line">        right = flag + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            <span class="keyword">if</span> left &gt;= <span class="number">0</span> <span class="keyword">and</span> right &lt;= <span class="built_in">len</span>(A) - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> target - A[left] &lt;= A[right] - target:</span><br><span class="line">                    res.append(A[left])</span><br><span class="line">                    left -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> target - A[left] &gt; A[right] - target:</span><br><span class="line">                    res.append(A[right])</span><br><span class="line">                    right += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> left &gt;= <span class="number">0</span> <span class="keyword">and</span> right &gt; <span class="built_in">len</span>(A) - <span class="number">1</span>:</span><br><span class="line">                res.append(A[left])</span><br><span class="line">                left -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> left &lt; <span class="number">0</span> <span class="keyword">and</span> right &lt;= <span class="built_in">len</span>(A) - <span class="number">1</span>:</span><br><span class="line">                res.append(A[right])</span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> left &lt; <span class="number">0</span> <span class="keyword">and</span> right &gt; <span class="built_in">len</span>(A) - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>lintcode</category>
      </categories>
  </entry>
  <entry>
    <title>lintcode-159-寻找旋转数组中的最小值-二分法</title>
    <url>/2022/02/17/lintcode-159-%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC-%E4%BA%8C%E5%88%86%E6%B3%95/</url>
    <content><![CDATA[<p><a href="https://www.lintcode.com/problem/159/">https://www.lintcode.com/problem/159/</a></p>
<h1 id="寻找旋转数组中的最小值"><a href="#寻找旋转数组中的最小值" class="headerlink" title="寻找旋转数组中的最小值"></a>寻找旋转数组中的最小值</h1><ul>
<li>判断mid是否为最小值</li>
<li>判断mid在上半区还是下半区</li>
<li>特殊情况：短数列、单调递增数列<span id="more"></span>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @param nums: a rotated sorted array</span></span><br><span class="line"><span class="string">    @return: the minimum number in the array</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMin</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span> </span><br><span class="line">        <span class="keyword">while</span> left + <span class="number">1</span> &lt; right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; nums[mid -  <span class="number">1</span>] <span class="keyword">and</span> nums[mid] &lt; nums[mid + <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> nums[mid]</span><br><span class="line">            <span class="keyword">elif</span> nums[<span class="number">0</span>] &gt; nums[-<span class="number">1</span>] <span class="keyword">and</span> nums[mid] &lt; nums[<span class="number">0</span>]:</span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">elif</span> nums[<span class="number">0</span>] &gt; nums[-<span class="number">1</span>] <span class="keyword">and</span> nums[mid] &gt; nums[<span class="number">0</span>]:</span><br><span class="line">                left = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> nums[left] &lt; nums[right]:</span><br><span class="line">            <span class="keyword">return</span> nums[left]</span><br><span class="line">        <span class="keyword">else</span> :</span><br><span class="line">            <span class="keyword">return</span> nums[right]</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>lintcode</category>
      </categories>
  </entry>
  <entry>
    <title>lintcode-183-木材加工-二分法</title>
    <url>/2022/02/17/lintcode-183-%E6%9C%A8%E6%9D%90%E5%8A%A0%E5%B7%A5-%E4%BA%8C%E5%88%86%E6%B3%95/</url>
    <content><![CDATA[<p><a href="https://www.lintcode.com/problem/183/description">https://www.lintcode.com/problem/183/description</a></p>
<h1 id="木材加工"><a href="#木材加工" class="headerlink" title="木材加工"></a>木材加工</h1><ul>
<li>按照切割木头的长度进行二分</li>
<li>木头长度的范围在 1 到 max(L)，在这个范围内二分出一个长度 length，然后看看以这个mid长度能切割出多少木头，如果少于 k 根，说明要短一些才行，如果多余 k，说明可以继续边长一些。<span id="more"></span>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @param L: Given n pieces of wood with length L[i]</span></span><br><span class="line"><span class="string">    @param k: An integer</span></span><br><span class="line"><span class="string">    @return: The maximum length of the small pieces</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">woodCut</span>(<span class="params">self, L, k</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> L:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        start, end = <span class="number">1</span>, <span class="built_in">max</span>(L)</span><br><span class="line">        <span class="keyword">while</span> start + <span class="number">1</span> &lt; end:</span><br><span class="line">            mid = (start + end) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> self.get_pieces(L, mid) &gt;= k:</span><br><span class="line">                start = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                end = mid</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">if</span> self.get_pieces(L, end) &gt;= k:</span><br><span class="line">            <span class="keyword">return</span> end</span><br><span class="line">        <span class="keyword">if</span> self.get_pieces(L, start) &gt;= k:</span><br><span class="line">            <span class="keyword">return</span> start    </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_pieces</span>(<span class="params">self, L, length</span>):</span></span><br><span class="line">        pieces = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> L:</span><br><span class="line">            pieces += l // length</span><br><span class="line">        <span class="keyword">return</span> pieces</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>lintcode</category>
      </categories>
  </entry>
  <entry>
    <title>lintcode-585-山脉序列中的最大值-二分法</title>
    <url>/2022/02/17/lintcode-585-%E5%B1%B1%E8%84%89%E5%BA%8F%E5%88%97%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC-%E4%BA%8C%E5%88%86%E6%B3%95/</url>
    <content><![CDATA[<p><a href="https://www.lintcode.com/problem/585/">https://www.lintcode.com/problem/585/</a></p>
<h1 id="山脉序列中的最大值"><a href="#山脉序列中的最大值" class="headerlink" title="山脉序列中的最大值"></a>山脉序列中的最大值</h1><ul>
<li>序列先增后减</li>
<li>选定mid后，判断mid值是封顶还是递增区间还是递减区间</li>
<li>考虑特殊情况<span id="more"></span>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @param nums: a mountain sequence which increase firstly and then decrease</span></span><br><span class="line"><span class="string">    @return: then mountain top</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mountainSequence</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left + <span class="number">1</span> &lt; right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid - <span class="number">1</span>] &lt; nums[mid] <span class="keyword">and</span> nums[mid] &gt; nums[mid + <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> nums[mid]</span><br><span class="line">            <span class="keyword">elif</span> nums[mid - <span class="number">1</span>] &lt; nums[mid] <span class="keyword">and</span> nums[mid] &lt; nums[mid + <span class="number">1</span>]:</span><br><span class="line">                left = mid</span><br><span class="line">            <span class="keyword">elif</span> nums[mid - <span class="number">1</span>] &gt; nums[mid] <span class="keyword">and</span> nums[mid] &gt; nums[mid + <span class="number">1</span>]:</span><br><span class="line">                right = mid</span><br><span class="line">        <span class="keyword">if</span> nums[left] &gt; nums[right]:</span><br><span class="line">            <span class="keyword">return</span> nums[left]</span><br><span class="line">        <span class="keyword">elif</span> nums[left] &lt;= nums[right]:</span><br><span class="line">            <span class="keyword">return</span> nums[right]</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>lintcode</category>
      </categories>
  </entry>
  <entry>
    <title>lintcode-75-寻找峰值-二分法</title>
    <url>/2022/02/17/lintcode-75-%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC-%E4%BA%8C%E5%88%86%E6%B3%95/</url>
    <content><![CDATA[<p><a href="https://www.lintcode.com/problem/75/">https://www.lintcode.com/problem/75/</a></p>
<h1 id="寻找峰值"><a href="#寻找峰值" class="headerlink" title="寻找峰值"></a>寻找峰值</h1><ul>
<li>mid在题中趋势存在四种情况：顶点、谷底、递增、递减<span id="more"></span>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @param A: An integers array.</span></span><br><span class="line"><span class="string">    @return: return any of peek positions.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findPeak</span>(<span class="params">self, A</span>):</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> A:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(A) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left + <span class="number">1</span> &lt; right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> A[mid] &gt; A[mid + <span class="number">1</span>] <span class="keyword">and</span> A[mid] &gt; A[mid - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> A[mid] &gt; A[mid - <span class="number">1</span>] <span class="keyword">and</span> A[mid] &lt; A[mid + <span class="number">1</span>]:</span><br><span class="line">                left = mid</span><br><span class="line">            <span class="keyword">elif</span> A[mid] &lt; A[mid - <span class="number">1</span>] <span class="keyword">and</span> A[mid] &gt; A[mid + <span class="number">1</span>]:</span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>lintcode-69-二叉树的层次遍历-双队列</title>
    <url>/2022/02/18/lintcode-69-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86-%E5%8F%8C%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p><a href="https://www.lintcode.com/problem/69/description">https://www.lintcode.com/problem/69/description</a></p>
<h1 id="二叉树的层次遍历"><a href="#二叉树的层次遍历" class="headerlink" title="二叉树的层次遍历"></a>二叉树的层次遍历</h1><ul>
<li>直接遍历队列的节点，节点值存为临时列表，节点的子节点存为临时队列</li>
<li>遍历结束当前队列，令queue = tempQueue继续循环<span id="more"></span></li>
</ul>
<p>```python<br>“””<br>Definition of TreeNode:<br>class TreeNode:<br>    def <strong>init</strong>(self, val):<br>        self.val = val<br>        self.left, self.right = None, None<br>“””</p>
<p>class Solution:<br>    “””<br>    @param root: A Tree<br>    @return: Level order a list of lists of integer<br>    “””<br>    def levelOrder(self, root):<br>        # write your code here<br>        if not root:<br>            return []</p>
<pre><code>    queue = [root]
    res = []
    while queue:
        tempQueue = []
        tempVal = []
        for node in queue:
            tempVal.append(node.val)
            if node.left:
                tempQueue.append(node.left)
            if node.right:
                tempQueue.append(node.right)
        res.append(tempVal)
        queue = tempQueue
    return res
</code></pre>
]]></content>
      <categories>
        <category>lintcode</category>
      </categories>
  </entry>
  <entry>
    <title>lintcode-69-二叉树的层次遍历-dummyNode法</title>
    <url>/2022/02/18/lintcode-69-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86-dummyNode%E6%B3%95/</url>
    <content><![CDATA[<p><a href="https://www.lintcode.com/problem/69/solution">https://www.lintcode.com/problem/69/solution</a></p>
<h1 id="二叉树的层次遍历"><a href="#二叉树的层次遍历" class="headerlink" title="二叉树的层次遍历"></a>二叉树的层次遍历</h1><ul>
<li>起始queue = [root, None]</li>
<li>while循环不断取队列中的节点</li>
<li>如果为正常节点，则取值加入临时值队列，取节点子节点入队</li>
<li>如果为None节点，则说明此层遍历结束，临时队列入结果队列，临时队列清空。并且，若queue为空则说明遍历结束，若queue不为空则None入队，继续下一层遍历。<span id="more"></span>
```python<br>“””<br>Definition of TreeNode:<br>class TreeNode:<br>  def <strong>init</strong>(self, val):<pre><code>  self.val = val
  self.left, self.right = None, None
</code></pre>
“””</li>
</ul>
<p>class Solution:<br>    “””<br>    @param root: A Tree<br>    @return: Level order a list of lists of integer<br>    “””<br>    def levelOrder(self, root):<br>        # write your code here<br>        if not root:<br>            return []</p>
<pre><code>    queue = [root, None]
    res = []
    tempVal = []
    while queue:           
        node = queue.pop(0)
        if node:
            tempVal.append(node.val)
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        elif node == None:
            res.append(tempVal)
            tempVal = []
            if queue:
                queue.append(None)
    return res
</code></pre>
]]></content>
      <categories>
        <category>lintcode</category>
      </categories>
  </entry>
  <entry>
    <title>lintcode-69-二叉树的层次遍历-单队列</title>
    <url>/2022/02/18/lintcode-69-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86-%E5%8D%95%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p><a href="https://www.lintcode.com/problem/69/description">https://www.lintcode.com/problem/69/description</a></p>
<h1 id="二叉树的层次遍历"><a href="#二叉树的层次遍历" class="headerlink" title="二叉树的层次遍历"></a>二叉树的层次遍历</h1><ul>
<li>把表头放入队列</li>
<li>用for来循环当前队列长度并出队，出队元素的值构成新列表加入结果列表，出队元素的左右节点加入队列尾部</li>
<li>直到队列为空，遍历结束<span id="more"></span>
```python<br>“””<br>Definition of TreeNode:<br>class TreeNode:<br>  def <strong>init</strong>(self, val):<pre><code>  self.val = val
  self.left, self.right = None, None
</code></pre>
“””</li>
</ul>
<p>class Solution:<br>    “””<br>    @param root: A Tree<br>    @return: Level order a list of lists of integer<br>    “””<br>    def levelOrder(self, root):<br>        # write your code here<br>        if not root:<br>            return []</p>
<pre><code>    queue = [root]
    res = []
    while queue:
        level = []
        for i in range(len(queue)):
            node = queue.pop(0)
            level.append(node.val)
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        res.append(level)
    return res
</code></pre>
]]></content>
      <categories>
        <category>lintcode</category>
      </categories>
  </entry>
  <entry>
    <title>九章算法-11-宽度优先搜索</title>
    <url>/2022/02/17/%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95-10-%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="宽度优先搜索BFS"><a href="#宽度优先搜索BFS" class="headerlink" title="宽度优先搜索BFS"></a>宽度优先搜索BFS</h1><ul>
<li>场景<ul>
<li>按层遍历图、树、矩阵</li>
<li>简单图的最短路径</li>
<li>连通块问题</li>
<li>找到所有方案</li>
<li>拓扑排序，实现容易程度远超DFS<span id="more"></span></li>
</ul>
</li>
</ul>
<h1 id="单队列"><a href="#单队列" class="headerlink" title="单队列"></a>单队列</h1><ul>
<li>单队列+for循环</li>
</ul>
<h1 id="双队列"><a href="#双队列" class="headerlink" title="双队列"></a>双队列</h1><ul>
<li>将头结点放Q1，遍历Q1子节点 放Q2，遍历Q2子节点放Q1</li>
</ul>
<h1 id="dummyNode"><a href="#dummyNode" class="headerlink" title="dummyNode"></a>dummyNode</h1><ul>
<li>永远指向链表的头结点</li>
<li>宽度优先搜索，1#23#45。加入头结点最后加入空指针，出队头结点加入子节点，出队空指针再入队空指针，每一层都被空指针隔开。</li>
</ul>
]]></content>
      <categories>
        <category>九章算法</category>
      </categories>
  </entry>
  <entry>
    <title>lintcode-480-二叉树的所有路径-分治法</title>
    <url>/2022/02/22/lintcode-480-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84-%E5%88%86%E6%B2%BB%E6%B3%95/</url>
    <content><![CDATA[<h1 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h1><ul>
<li>先判断空节点的情况</li>
<li>判断叶子节点的情况，因为叶子节点没有left和right,无法记录到答案中</li>
<li>逻辑是用根节点的值加上左节点遍历与右节点遍历，返回最终结果<span id="more"></span>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> (</span><br><span class="line">    <span class="type">List</span>,</span><br><span class="line">)</span><br><span class="line"><span class="keyword">from</span> lintcode <span class="keyword">import</span> (</span><br><span class="line">    TreeNode,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Definition of TreeNode:</span></span><br><span class="line"><span class="string">class TreeNode:</span></span><br><span class="line"><span class="string">    def __init__(self, val):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.left, self.right = None, None</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @param root: the root of the binary tree</span></span><br><span class="line"><span class="string">    @return: all root-to-leaf paths</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">binary_tree_paths</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">if</span> root.left == <span class="literal">None</span> <span class="keyword">and</span> root.right == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="built_in">str</span>(root.val)]</span><br><span class="line"></span><br><span class="line">        leftpath = self.binary_tree_paths(root.left)</span><br><span class="line">        rightpath = self.binary_tree_paths(root.right)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> path <span class="keyword">in</span> leftpath:</span><br><span class="line">            res.append(<span class="built_in">str</span>(root.val) + <span class="string">&quot;-&gt;&quot;</span> + path)</span><br><span class="line">        <span class="keyword">for</span> path <span class="keyword">in</span> rightpath:</span><br><span class="line">            res.append(<span class="built_in">str</span>(root.val) + <span class="string">&quot;-&gt;&quot;</span> + path)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>lintcode</category>
      </categories>
  </entry>
  <entry>
    <title>lintcode-480-二叉树的所有路径-回溯法</title>
    <url>/2022/02/22/lintcode-480-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84-%E5%9B%9E%E6%BA%AF%E6%B3%95/</url>
    <content><![CDATA[<h1 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h1><ul>
<li>深度优先搜索，回溯法</li>
<li>注意dfs参数设置</li>
<li>str()函数，.join()函数<span id="more"></span>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> (</span><br><span class="line">    <span class="type">List</span>,</span><br><span class="line">)</span><br><span class="line"><span class="keyword">from</span> lintcode <span class="keyword">import</span> (</span><br><span class="line">    TreeNode,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Definition of TreeNode:</span></span><br><span class="line"><span class="string">class TreeNode:</span></span><br><span class="line"><span class="string">    def __init__(self, val):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.left, self.right = None, None</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @param root: the root of the binary tree</span></span><br><span class="line"><span class="string">    @return: all root-to-leaf paths</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">binary_tree_paths</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        self.dfs(root, [<span class="built_in">str</span>(root.val)], res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self, node, temp, res</span>):</span></span><br><span class="line">        <span class="keyword">if</span> node.left == <span class="literal">None</span> <span class="keyword">and</span> node.right == <span class="literal">None</span>:</span><br><span class="line">            res.append(<span class="string">&quot;-&gt;&quot;</span>.join(temp))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            temp.append(<span class="built_in">str</span>(node.left.val))</span><br><span class="line">            self.dfs(node.left, temp, res)</span><br><span class="line">            temp.pop()</span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            temp.append(<span class="built_in">str</span>(node.right.val))</span><br><span class="line">            self.dfs(node.right, temp, res)</span><br><span class="line">            temp.pop()</span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>lintcode</category>
      </categories>
  </entry>
  <entry>
    <title>lintcode-67-二叉树的中序遍历-递归法</title>
    <url>/2022/02/23/lintcode-67-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86-%E9%80%92%E5%BD%92%E6%B3%95/</url>
    <content><![CDATA[<h1 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h1><ul>
<li>根节点左侧中序遍历 + 根节点值 + 根节点右侧中序遍历<span id="more"></span>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> (</span><br><span class="line">    <span class="type">List</span>,</span><br><span class="line">)</span><br><span class="line"><span class="keyword">from</span> lintcode <span class="keyword">import</span> (</span><br><span class="line">    TreeNode,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Definition of TreeNode:</span></span><br><span class="line"><span class="string">class TreeNode:</span></span><br><span class="line"><span class="string">    def __init__(self, val):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.left, self.right = None, None</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @param root: A Tree</span></span><br><span class="line"><span class="string">    @return: Inorder in ArrayList which contains node values.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorder_traversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        leftList = self.inorder_traversal(root.left)</span><br><span class="line">        rightList = self.inorder_traversal(root.right)</span><br><span class="line">        <span class="keyword">return</span> leftList + [root.val] + rightList</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>lintcode</category>
      </categories>
  </entry>
  <entry>
    <title>lintcode-67-二叉树的中序遍历-栈迭代</title>
    <url>/2022/02/23/lintcode-67-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86-%E6%A0%88%E8%BF%AD%E4%BB%A3/</url>
    <content><![CDATA[<h1 id="栈迭代"><a href="#栈迭代" class="headerlink" title="栈迭代"></a>栈迭代</h1><ul>
<li>构造栈来保存节点</li>
<li>首先栈顶的左节点一次入栈，相当于第一次dfs</li>
<li>而后从栈中开始pop,如果当前节点无右节点则说明当前节点为以该节点为根节点的中序遍历的最后节点，因为其左子树均pop，结果记录并弹出该节点即可</li>
<li>如果当前节点存在右节点，则需要再结果记录该节点后遍历它的右子树，需要将右子树的第一个dfs入栈，再重复弹出操作<span id="more"></span>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> (</span><br><span class="line">    <span class="type">List</span>,</span><br><span class="line">)</span><br><span class="line"><span class="keyword">from</span> lintcode <span class="keyword">import</span> (</span><br><span class="line">    TreeNode,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Definition of TreeNode:</span></span><br><span class="line"><span class="string">class TreeNode:</span></span><br><span class="line"><span class="string">    def __init__(self, val):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.left, self.right = None, None</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @param root: A Tree</span></span><br><span class="line"><span class="string">    @return: Inorder in ArrayList which contains node values.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorder_traversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        stack = []</span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        temp = root</span><br><span class="line">        <span class="keyword">while</span> temp:</span><br><span class="line">            stack.append(temp)</span><br><span class="line">            temp = temp.left</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            curNode = stack.pop()</span><br><span class="line">            res.append(curNode.val)</span><br><span class="line">            <span class="keyword">if</span> curNode.right:</span><br><span class="line">                temp = curNode.right</span><br><span class="line">                <span class="keyword">while</span> temp:</span><br><span class="line">                    stack.append(temp)</span><br><span class="line">                    temp = temp.left</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>lintcode</category>
      </categories>
  </entry>
  <entry>
    <title>九章算法-12-深度优先搜索</title>
    <url>/2022/02/21/%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95-12-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<h1 id="遍历法与分治法"><a href="#遍历法与分治法" class="headerlink" title="遍历法与分治法"></a>遍历法与分治法</h1><ul>
<li>遍历法 = 一个小人拿着一个记事本走遍所有节点</li>
<li>分治法 = 分配小弟去做子任务，自己进行结果汇总</li>
<li>分治法 = 左子树所有路径 + 右子树所有路径 具有returnValue 效率并非最高</li>
<li>分治法条件：问题可分割且形式一样；可以用参数可以描述问题规模</li>
<li>二叉树遍历：左子树，右子树，叶子节点（90%不需要处理）</li>
<li>遍历法：通常会用到一个全局变量或者共享参数</li>
<li>分治法：通常将利用returnValue记录子问题结果，二叉树上的分治法本质上也是在做遍历——后序遍历<span id="more"></span>
<h1 id="递归、深搜、回溯的区别"><a href="#递归、深搜、回溯的区别" class="headerlink" title="递归、深搜、回溯的区别"></a>递归、深搜、回溯的区别</h1></li>
<li>函数进行自我调用，大问题的结果依赖于小问题的结果</li>
<li>深搜，可以用递归实现，也可以自己创建stack存放每一层的参数</li>
<li>搜索树</li>
<li>回溯法：就是深度优先搜索算法</li>
<li>回溯操作：递归函数在回到上一层递归调用处的时候，一些参数需要改回到调用之前的值，这个擦走就是回溯。</li>
</ul>
<h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><ul>
<li>找点 vs 找路径</li>
<li>binary-tree-paths</li>
<li>回溯找路径：append——操作——pop</li>
<li>python不建议用字符串加法，会产生新字符串 </li>
</ul>
<h1 id="判断二叉树是否平衡"><a href="#判断二叉树是否平衡" class="headerlink" title="判断二叉树是否平衡"></a>判断二叉树是否平衡</h1><ul>
<li>balanced-binary-tree</li>
</ul>
]]></content>
      <categories>
        <category>九章算法</category>
      </categories>
  </entry>
  <entry>
    <title>九章算法-13-二叉树非递归遍历</title>
    <url>/2022/02/23/%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95-13-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h1 id="二叉树中序遍历递归实现"><a href="#二叉树中序遍历递归实现" class="headerlink" title="二叉树中序遍历递归实现"></a>二叉树中序遍历递归实现</h1><ul>
<li>前序遍历、中序遍历、后续遍历</li>
<li>binary-search-tree-iterator</li>
<li>lintcode-67-二叉树的中序遍历<span id="more"></span>
<h1 id="二叉树中序遍历非递归"><a href="#二叉树中序遍历非递归" class="headerlink" title="二叉树中序遍历非递归"></a>二叉树中序遍历非递归</h1></li>
<li>自己控制原来由操作系统控制的栈的进出</li>
<li>找到最小的点，即二叉树最左边的点</li>
<li>在stack中记录从根节点到当前节点的整条路径</li>
<li>下一个节点 = 右子树最小点 or 路径中最近的一个通过左子树包含当前点的点<h1 id="另一种二叉树中序遍历非递归"><a href="#另一种二叉树中序遍历非递归" class="headerlink" title="另一种二叉树中序遍历非递归"></a>另一种二叉树中序遍历非递归</h1></li>
<li>通过实现hasNext和next两个方法，从而实现二叉查找树的中序遍历迭代器</li>
<li>lintcode-86</li>
</ul>
]]></content>
      <categories>
        <category>九章算法</category>
      </categories>
  </entry>
  <entry>
    <title>HCIP-01-防火墙上</title>
    <url>/2022/02/28/HCIP-01-%E9%98%B2%E7%81%AB%E5%A2%99%E4%B8%8A/</url>
    <content><![CDATA[<h1 id="四大部分"><a href="#四大部分" class="headerlink" title="四大部分"></a>四大部分</h1><ul>
<li>路由交换、防火墙、无线、自动化<span id="more"></span>
<h1 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h1></li>
<li>保障网络安全性：阻挡非法用户与流量、许可合法用户与流量</li>
<li>交换机最便宜、路由器贵一点、防火墙最贵</li>
<li>交换机：接入、汇聚、提供大量接口</li>
<li>路由器：三层转发、打通一个又一个局域网</li>
<li>防火墙：控制报文转发、防攻击、7层设备（应用层过滤、3-4层也能过滤）</li>
<li>NGFW：下一代防火墙、访问控制、应用过滤、状态监测</li>
<li>ensp模拟器：usg6000v-导入配置文件-.udi导入-用户名密码admin/Admin@123-修改密码包涵数字大写特殊字符</li>
<li>硬件防火墙放在出口路由器之外；或者双层防火墙出口和内网；旁挂放于路由与交换旁边</li>
<li>WAF：web应用防火墙</li>
<li>防火墙-安全区域-信任度-接口分区：trust85、dmz50、untrust5</li>
<li>防火墙本身区域100：local100</li>
<li>untrust区域用在出口</li>
<li>网络通就设置any/any</li>
</ul>
]]></content>
      <categories>
        <category>HCIP</category>
      </categories>
  </entry>
  <entry>
    <title>HCIP-02-防火墙下</title>
    <url>/2022/02/28/HCIP-02-%E9%98%B2%E7%81%AB%E5%A2%99%E4%B8%8B/</url>
    <content><![CDATA[<h1 id="防火墙下"><a href="#防火墙下" class="headerlink" title="防火墙下"></a>防火墙下</h1><ul>
<li>主要工作是控制，默认的策略都是拒绝，区域是基于接口划分的，一个区域可以拥有多个接口<ul>
<li>local 100</li>
<li>trust 85</li>
<li>dmz 50</li>
<li>untrust 5</li>
</ul>
</li>
<li>跨区域访问：高到低优先级为out;低到高优先级为in<span id="more"></span></li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>HCIP</category>
      </categories>
  </entry>
  <entry>
    <title>九章算法-14-宽度优先搜索2</title>
    <url>/2022/02/24/%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95-14-%E5%AE%BD%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A22/</url>
    <content><![CDATA[<h1 id="连通块问题"><a href="#连通块问题" class="headerlink" title="连通块问题"></a>连通块问题</h1><ul>
<li>通过一个点找到图中联通的所有点</li>
<li>非递归的方式找到所有方案</li>
<li>简单图没有方向没有权重两点间只有一条线，复杂图有方向有权重<span id="more"></span></li>
<li>n个点m个边，时间复杂度O(m+n) m最大是n(n-1)/2</li>
<li>lintcode-137-克隆图 寻找点 复制点 复制边 分开<ol>
<li>找到所有点:bfs</li>
<li>复制所有点</li>
<li>复制所有边</li>
<li>不要写高耦合代码，写成三个函数</li>
</ol>
</li>
</ul>
<h1 id="分层遍历"><a href="#分层遍历" class="headerlink" title="分层遍历"></a>分层遍历</h1><ul>
<li>图的层次遍历：使用dict/set来记录点是否被遍历过</li>
<li>简单图最短路径<ul>
<li>简单图没有方向，没有权重</li>
<li>简单图的两点之间只有一条边，自己不连自己</li>
<li>使用queue = collections.deque([node])</li>
<li>用visited标记已入队的点,一旦入队就要马上标记访问，否则会有重复元素入队</li>
<li>n点m边，时间复杂度O(m+n)</li>
</ul>
</li>
<li>lintcode-120-单词接龙</li>
<li>矩阵中的宽度优先搜索<ul>
<li>lintcode-433-numberOfIslands</li>
<li>matrix + 连通块 = bfs/dfs</li>
<li>工程上一般不会修改源数据</li>
<li>lintcode-611-knightShortestPath</li>
</ul>
</li>
</ul>
<h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><ul>
<li>求任意拓扑排序：lintcode-127<ol>
<li>统计每个点入度：有向图中指向某点的线段数</li>
<li>将每个入度为0的点放入队列中作为起始节点</li>
<li>不断出队，去掉该点的所有连边，其他点相应入度-1</li>
<li>一旦发现新的入度为0的点，丢回队列中</li>
</ol>
</li>
<li>拓扑排序并不是传统排序算法</li>
<li>一个图可能存在多个拓扑排序</li>
<li>求是否有拓扑排序：lintcode-616,图+有依赖关系+有向无环=拓扑排序</li>
<li>求是否唯一拓扑排序:lintcode-605,判断queue长度是否大于1，若大于1则表示有多个选择</li>
<li>求字典序最小的拓扑排序：lintcode-892</li>
</ul>
<h1 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h1><ul>
<li>图上BFS<ul>
<li>判断一个图是否是一棵树 graph-valid-tree</li>
<li>搜索图中最近值为target的点<br>search-graph-nodes</li>
<li>无向图连通块 connected-component-in-undirected-graph  </li>
</ul>
</li>
<li>矩阵上的bfs<ul>
<li>僵尸多少天吃掉所有人 zombie-in-matrix</li>
<li>邮政局问题 build-post-office-ii</li>
</ul>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>能用bfs就不用dfs除非面试官要求</li>
<li>bfs三场景：连通块、层级遍历、拓扑排序</li>
</ul>
]]></content>
      <categories>
        <category>九章算法</category>
      </categories>
  </entry>
  <entry>
    <title>lintcode-86-二叉查找树迭代器-栈bfs</title>
    <url>/2022/02/24/lintcode-86-%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8-%E6%A0%88bfs/</url>
    <content><![CDATA[<h1 id="二叉查找树迭代器"><a href="#二叉查找树迭代器" class="headerlink" title="二叉查找树迭代器"></a>二叉查找树迭代器</h1><ul>
<li>思路类似67-二叉树的中序遍历-栈迭代</li>
<li>初始化的时候要对根节点进行左节点迭代进栈<span id="more"></span>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Definition of TreeNode:</span></span><br><span class="line"><span class="string">class TreeNode:</span></span><br><span class="line"><span class="string">    def __init__(self, val):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.left, self.right = None, None</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Example of iterate a tree:</span></span><br><span class="line"><span class="string">iterator = BSTIterator(root)</span></span><br><span class="line"><span class="string">while iterator.hasNext():</span></span><br><span class="line"><span class="string">    node = iterator.next()</span></span><br><span class="line"><span class="string">    do something for node </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @param: root: The root of binary tree.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="comment"># do intialization if necessary</span></span><br><span class="line">        self.stack = []</span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            self.stack.append(root)</span><br><span class="line">            root = root.left</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @return: True if there has next node, or false</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasNext</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.stack) &gt; <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @return: return next node</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_next</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.stack) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        curNode = self.stack.pop()</span><br><span class="line">        <span class="keyword">if</span> curNode.right:</span><br><span class="line">            temp = curNode.right</span><br><span class="line">            <span class="keyword">while</span> temp:</span><br><span class="line">                self.stack.append(temp)</span><br><span class="line">                temp = temp.left</span><br><span class="line">        <span class="keyword">return</span> curNode</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>lintcode</category>
      </categories>
  </entry>
  <entry>
    <title>lintcode-137-克隆图-bfs</title>
    <url>/2022/03/03/lintcode-137-%E5%85%8B%E9%9A%86%E5%9B%BE-bfs/</url>
    <content><![CDATA[<h1 id="克隆图"><a href="#克隆图" class="headerlink" title="克隆图"></a>克隆图</h1><ol>
<li>找到所有的点，应用bfs和set()</li>
<li>复制所有的点，将映射关系存起来,应用dic()</li>
<li>找到所有的边，复制每一条边</li>
<li>分子涵书写，去耦合更容易阅读<span id="more"></span>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> lintcode <span class="keyword">import</span> (</span><br><span class="line">    UndirectedGraphNode,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Definition for a UndirectedGraphNode:</span></span><br><span class="line"><span class="string">class UndirectedGraphNode:</span></span><br><span class="line"><span class="string">    def __init__(self, label):</span></span><br><span class="line"><span class="string">        self.label = label</span></span><br><span class="line"><span class="string">        self.neighbors = []</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @param node: A undirected graph node</span></span><br><span class="line"><span class="string">    @return: A undirected graph node</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clone_graph</span>(<span class="params">self, node: UndirectedGraphNode</span>) -&gt; UndirectedGraphNode:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">        nodeSet = self.getNodes(node)</span><br><span class="line">        nodeDic = self.cloneNodes(nodeSet)</span><br><span class="line">        self.cloneLines(nodeSet, nodeDic)</span><br><span class="line">        <span class="keyword">return</span> nodeDic[node]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getNodes</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        res = <span class="built_in">set</span>([node])</span><br><span class="line">        queue = [node]</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            popNode = queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">for</span> temp <span class="keyword">in</span> popNode.neighbors:</span><br><span class="line">                <span class="keyword">if</span> temp <span class="keyword">in</span> res:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                res.add(temp)</span><br><span class="line">                queue.append(temp)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cloneNodes</span>(<span class="params">self, nodeSet</span>):</span></span><br><span class="line">        res = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> nodeSet:</span><br><span class="line">            res[node] = UndirectedGraphNode(node.label)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cloneLines</span>(<span class="params">self, nodeSet, nodeDic</span>):</span></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> nodeSet:</span><br><span class="line">            tempNeighbors = []</span><br><span class="line">            <span class="keyword">for</span> neighbor <span class="keyword">in</span> node.neighbors:</span><br><span class="line">                tempNeighbors.append(nodeDic[neighbor])</span><br><span class="line">            nodeDic[node].neighbors = tempNeighbors</span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>lintcode</category>
      </categories>
  </entry>
  <entry>
    <title>lintcode-120-单词接龙-bfs</title>
    <url>/2022/03/03/lintcode-120-%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99-bfs/</url>
    <content><![CDATA[<h1 id="单词接龙"><a href="#单词接龙" class="headerlink" title="单词接龙"></a>单词接龙</h1><ul>
<li>因为对于每一次变化，都只往下走一步。for i in range(len(queue)):保证了每次都只在上一次改变的基础上改变一个字母。 </li>
<li>比如第一次 hot 变成 <em>ot, h</em>t, ho*,  如果这些结果里没有的话，再对于每一个queue里的单词，都再改变一个字母。 这样每一批点（即distance相同的点）都是同时迈入下一步的，所以最先等于end的点，就代表了最近的distance。</li>
<li>相当于n叉树的层次遍历，n为单词长度<!--mroe-->
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @param: start: a string</span></span><br><span class="line"><span class="string">    @param: end: a string</span></span><br><span class="line"><span class="string">    @param: dict: a set of string</span></span><br><span class="line"><span class="string">    @return: An integer</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ladderLength</span>(<span class="params">self, start, end, dictionary</span>):</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        dictionary.add(end)</span><br><span class="line">        queue = [start]</span><br><span class="line">        visited = []</span><br><span class="line">        distance = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            distance += <span class="number">1</span></span><br><span class="line">            length = <span class="built_in">len</span>(queue)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">                curWord = queue.pop(<span class="number">0</span>)               </span><br><span class="line">                <span class="keyword">if</span> curWord == end:</span><br><span class="line">                    <span class="keyword">return</span> distance</span><br><span class="line">                <span class="keyword">if</span> curWord <span class="keyword">in</span> visited:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> curWord <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                    visited.append(curWord)</span><br><span class="line">                    nextWords = self.getNextWords(curWord, visited, dictionary)</span><br><span class="line">                    queue.extend(nextWords)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getNextWords</span>(<span class="params">self, word, visited, dictionary</span>):</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(word)):</span><br><span class="line">            left, right = word[<span class="number">0</span>:i], word[i+<span class="number">1</span>:]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">26</span>):</span><br><span class="line">                temp = left + <span class="built_in">chr</span>(<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>) + j) + right</span><br><span class="line">                <span class="keyword">if</span> temp <span class="keyword">not</span> <span class="keyword">in</span> visited <span class="keyword">and</span> temp <span class="keyword">in</span> dictionary:</span><br><span class="line">                    res.append(temp)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>lintcode</category>
      </categories>
  </entry>
  <entry>
    <title>lintcode-433-岛屿的个数-bfs</title>
    <url>/2022/03/03/lintcode-433-%E5%B2%9B%E5%B1%BF%E7%9A%84%E4%B8%AA%E6%95%B0-bfs/</url>
    <content><![CDATA[<h1 id="岛屿的个数"><a href="#岛屿的个数" class="headerlink" title="岛屿的个数"></a>岛屿的个数</h1><ul>
<li>遍历每一个点，如果发现为1的点就进行宽度优先搜索，建立一个集合保存搜索到为1的点的坐标，再次遇到搜索过的点时就跳过该点<span id="more"></span>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> (</span><br><span class="line">    <span class="type">List</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    @param grid: a boolean 2D matrix</span></span><br><span class="line"><span class="string">    @return: an integer</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">num_islands</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">bool</span>]]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> grid <span class="keyword">or</span> <span class="keyword">not</span> grid[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        islands = <span class="number">0</span></span><br><span class="line">        visited = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="number">1</span> <span class="keyword">and</span> (i, j) <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                    islands += <span class="number">1</span></span><br><span class="line">                    visited.add((i, j))</span><br><span class="line">                    self.bfs(i, j, grid, visited)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> islands</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bfs</span>(<span class="params">self, i, j, grid, visited</span>):</span></span><br><span class="line">        queue = [(i, j)]</span><br><span class="line">        direction = [(<span class="number">1</span>,<span class="number">0</span>),(-<span class="number">1</span>,<span class="number">0</span>),(<span class="number">0</span>,<span class="number">1</span>),(<span class="number">0</span>,-<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            x, y = queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">for</span> dx, dy <span class="keyword">in</span> direction:</span><br><span class="line">                <span class="keyword">if</span> x + dx &lt; <span class="number">0</span> <span class="keyword">or</span> x + dx &gt;= <span class="built_in">len</span>(grid) <span class="keyword">or</span> y + dy &lt; <span class="number">0</span> <span class="keyword">or</span> y + dy &gt;= <span class="built_in">len</span>(grid[<span class="number">0</span>]):</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> (x + dx, y + dy) <span class="keyword">not</span> <span class="keyword">in</span> visited <span class="keyword">and</span> grid[x + dx][y + dy] == <span class="number">1</span>:</span><br><span class="line">                    visited.add((x + dx, y + dy))</span><br><span class="line">                    queue.append((x + dx, y + dy))</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>lintcode</category>
      </categories>
  </entry>
</search>
